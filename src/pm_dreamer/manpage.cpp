/***************************************************************************
                                 manpage.cpp
                             -------------------
                               W. Michael Brown

  Text for manpage chapters

 __________________________________________________________________________
    This file is part of the PM-Dreamer project
 __________________________________________________________________________

    begin                : Jun 6 2008
    copyright            : (C) 2008 by W. Michael Brown
    email                : wmbrown@sandia.gov
 ***************************************************************************/

/* -----------------------------------------------------------------------
   Copyright (2009) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under 
   the GNU General Public License.
   ----------------------------------------------------------------------- */

#include "commandline.h"

void AddChapters(CommandLine &cl) {

  // Short Description
  cl.addtoman_chapter("NAME","Optimization of functional forms for particle mechanics.");

  // Version
  cl.addtoman_chapter("VERSION","Version 0.2");

  // Full Description
  const std::string desc[74]={
    "PM-Dreamer is software for generation of empirical models for particle ",
    "mechanics. The software takes as input data from a series of particle configurations ",
    "and the corresponding energies and/or particle forces associated with those ",
    "configurations. The output from PM-Dreamer is a set of functions that ",
    "can potentially be used to calculate configuration energies for particles ",
    "giving the force-field necessary for particle simulations.\n\n",
    
    "PM-Dreamer obtains the equations for energy calculation using a ",
    "combination of genetic programming and local search in order to ",
    "minimize the root-mean square error in the calculation of energy ",
    "and/or particle force. The genetic programming is based on the ",
    "Open-BEAGLE library for evolutionary computation. This library ",
    "has been extended in PM-Dreamer to allow for massively parellel ",
    "optimization, hybrid local search, vectorized expression ",
    "evaluation, template-based evaluation of fitnesses using ",
    "particle configurations with periodic boundary conditions for ",
    "2 and 3-body particle interactions, and parallel restarts with ",
    "the capability to switch datasets and/or function templates.\n\n",
    
    "The input for PM-Dreamer consists of the input_data file ",
    "that contains particle configuration data and the beagle_config_file ",
    "that facilitates parameterization of the optimization. The formats ",
    "available for the input_data are described in the Fitness Evaluation ",
    "section and can be specified with the -t flag. The format for the ",
    "beagle_config_file is taken from Open Beagle with the extensions ",
    "described throughout this documentation. Examples for both ",
    "should have been included with the software package.\n\n",
    
    "There are three types of output for PM-Dreamer. Console output ",
    "describes the progress and statistics of the run and is controlled ",
    "with the -n flag. Log file output also describes statistics in XML as ",
    "specified in the beagle_config_file. The default filename for ",
    "the log file for serial runs is gp_force.log. For parallel runs ",
    "a separate log file is written for each process with the default name ",
    "gp_force_RR.log where RR is the process rank. The final output format ",
    "consists of milestone files. These files contain an XML description ",
    "of all of the expressions at a given point in the optimization ",
    "and are also used to restart runs. The default name for the milestone ",
    "files is gp_force.obm for serial or gp_force_RR.obm for parallel runs. ",
    "Utilities for generating plots from the log files and graphic ",
    "representations of expressions should have been included with ",
    "this software package.\n\n",
    
    "The following definitions are used throughout the documentation:\n",
    ".TP \\fBIndividual\\fR A single mathematical expression for calculation ",
    "of the energies of particle configurations.",
    ".TP \\fBPrimitive\\fR A primitive is a node in the expression tree. ",
    "Examples of primitives include unary and binary mathematical expressions, ",
    "variables used to describe the particle configurations, and constants ",
    "in the expression.",
    ".TP \\fBTerminal/Constant/Ephemeral\\fR A terminal is a primitive ",
    "that takes no arguments. A constant/ephemeral is a terminal that is not used as ",
    "a variable in the expression. Constants are typically randomly generated ",
    "and can change during the optimization by mutation to generate a new ",
    "random number or by local search executed to optimize the constants ",
    "in an expression. Constants that should not be modified (such as pi) ",
    "can also be specified.",
    ".TP \\fBFitness\\fR A metric describing the error in an Individuals' ",
    "calculation of the energy using the training data.",
    ".TP \\fBPopulation/Deme\\fR A population or deme is a group of ",
    "individuals that evolve together. Crossover occurs using multiple ",
    "individuals from a population and selection occurs based on ",
    "the individuals in a single population. Multiple populations ",
    "can be used in a run. The populations evolve separately, but can ",
    "interact through migration of individuals between the populations.",
    ".TP \\fBIsland\\fR Here, an island is used in parallel runs to describe ",
    "the population or set of populations undergoing evolution in a single ",
    "MPI process.",
    ".TP \\fBVivarium\\fR All of the populations involed in a run. ",
    ".TP \\fBHall of Fame\\fR The Hall of Fame contains the \\fIn\\fR ",
    "individuals with the best fitness(es) found during a run.",
    ".TP \\fBMilestone/Restart File\\fR These files contain the output ",
    "of all of the individuals at some point in the optimization and have ",
    "the extension .obm"
    ".TP \\fBHybrid Optimization/Local Search\\fR Hybrid optimization ",
    "occurs separately from the evolutionary optimization. With a specified ",
    "probability, local search is performed on an individual to optimize 1 ",
    "or multiple constants.\n\n"
  };
  cl.addtoman_chapter("DESCRIPTION",74,desc);

  const std::string config[57]={
    "The Beagle configuration file is used to control the optimization including ",
    "the functions, terminals, operators, and replacement strategies that ",
    "are used. Deatils on each section follow. ",
    "A template for a configuration files is:\n\n",
    "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n",
    "<Beagle>\n",
    "  <Evolver>\n",
    "    <BootStrapSet>\n",
    "    \n",
    "      ... \\fIPopulation Initialization\\fR ...\n",
    "\n",
    "    </BootStrapSet>\n",
    "    <MainLoopSet>\n",
    "\n",
    "      ... \\fIReplacement Strategy\\fR ...\n",
    "        \n",
    "        ... \\fIFitness Evaluation\\fR ...\n",
    "\n",
    "          ... \\fICrossover\\fR ...\n",
    "        \n",
    "            ... \\fISelection\\fR ...\n",
    "\n",
    "        ... \\fIFitness Evaluation\\fR ...\n",
    "\n",
    "          ... \\fIMutation\\fR ...\n",
    "\n",
    "            ... \\fISelection\\fR ...\n",
    "        \n",
    "        ... \\fISelection\\fR ...\n",
    "        \n",
    "      ... \\fIMigration\\fR ...\n",
    "        \n",
    "      ... \\fIStatistics\\fR ...\n",
    "      \n",
    "      ... \\fITermination Criteria\\fR ...\n",
    "      \n",
    "      ... \\fIRestart File Output\\fR ...\n",
    "      \n",
    "    </MainLoopSet>\n",
    "  </Evolver>\n",
    "  <System>\n",
    "  <PrimitiveSuperSet>\n",
    "    <PrimitiveSet>\n",
    "\n",
    "      ... \\fIFunctions\\fR ...\n",
    "      \n",
    "      ... \\fITerminals\\fR ...\n",
    "      \n",
    "    </PrimitiveSet>\n",
    "  </PrimitiveSuperSet>\n",
    "  <Register>\n",
    "    \n",
    "      ... \\fIRegister values\\fR ...\n",
    "  \n",
    "  </Register>\n",
    "  </System>\n",
    "</Beagle>\n"
  };
  cl.addtoman_chapter("BEAGLE CONFIGURATION FILE",57,config);
  
  const std::string popi[25]={
    "The initialization is accomplished using the following operators:\n",
    "\\fBGP-InitHalfOp\\fR .TP Koza's ramped half-and-half generative method. An equal number of expression trees are generated using a depth parameter that ranges between 2 and the maximum specified depth\n\n",
    "\\fBGP-InitFullOp\\fR .TP The initial population will consist of expression trees that all have a depth equal to the maximum depth.\n\n",
    "\\fBGP-InitGrowOp\\fR .TP The initial population consists of expression trees of variable depths.\n\n",
    "\\fBRestartReadOp\\fR .TP Read in population from a restart ",
    "(milestone) file. ",
    "This operator replaces the MilestoneReadOp operator in Open Beagle ",
    "to allow the parameters in the beagle_config_file to override those ",
    "in the milestone file. ",
    "The example below checks to see if the register, ms.restart.file, ",
    "is set. If it is, a restart file is read in. Otherwise, a ",
    "population is generated using half-and-half followed by ",
    "fitness evaluation and statistics output:\n\n",
    "<BootStrapSet>\n",
    "  <IfThenElseOp parameter=\"ms.restart.file\" value=\"\">\n",
    "    <PositiveOpSet>\n",
    "      <GP-InitHalfOp/>\n",
    "      <EnergyOp/>\n",
    "      <GP-StatsCalcFitnessSimpleOp/>\n",
    "    </PositiveOpSet>\n",
    "    <NegativeOpSet>\n",
    "      <RestartReadOp/>\n",
    "    </NegativeOpSet>\n",
    "  </IfThenElseOp>\n",
    "</BootStrapSet>\n"
  };
  cl.addtoman_chapter("POPULATION INITIALIZATION",25,popi);
  
  const std::string replaces[16]={
    "The replacement strategy is specified using the follow operators:\n",
    "\\fBDecimateOp\\fR .TP Shrink the population size by keeping the n best individuals\n\n",
    "\\fBGenerationalOp\\fR .TP Breeding tree following a generation by generation replacement strategy\n\n",
    "\\fBHierarchicalFairCompetitionOp\\fR .TP HCF operator inspired by the work of Hu and Goodman\n\n",
    "\\fBMigrationRandomRingOp\\fR .TP Migrate randomly chosen individuals between populations using a ring topology\n\n",
    "\\fBMuCommaLambdaOp\\fR .TP A (Mu,Lambda) operator generates Lambda children individuals from a population of Mu parents(where Lambda > Mu). From these Lambda individual, it keeps the Mu best to constitute the new generation.\n\n",
    "\\fBMuPlusLambdaOp\\fR .TP A (Mu+Lambda) operator generates Lambda children individuals from a population of Mu parents (usually where Lambda > Mu). From the Mu parents and the Lambda individual, it keeps the Mu best  individuals to constitute the new generation.\n\n",
    "\\fBNSGA2Op\\fR .TP The NSGA2 replacement strategy implement the elitist multiobjective evolutionary algorithm NSGA2 (Non-dominating Sorting Genetic Algorithm)\n\n",
    "\\fBOversizeOp\\fR .TP An oversize operator generates (ratio * population size) children individuals from a population of Mu parents.\n\n",
    "\\fBSteadyStateOp\\fR .TP Steady state replacement strategy operator\n\n"
  };
  cl.addtoman_chapter("REPLACEMENT STRATEGY AND MIGRATION",16,replaces);
  
  const std::string crossover[15]={
    "Crossover and mutation are specified using the follow operators:\n",
    "\\fBGP-CrossoverOp\\fR .TP Crossover of two individuals to produce a new individual\n\n",
    "\\fBGP-MutationEphemeralDoubleOp\\fR .TP Mutate the value of a randomly chosen double precision constant in the tree\n\n",
    "\\fBGP-MutationShrinkOp\\fR .TP Replace a randomly chosen branch with a randomly chosen argument on the branch\n\n",
    "\\fBGP-MutationStandardOp\\fR .TP Canonical GP Mutation\n\n",
    "\\fBGP-MutationSwapOp\\fR .TP Swap nodes in the expression tree\n\n",
    "\\fBGP-MutationSwapSubtreeOp\\fR .TP Swap branches in the expression tree\n\n",
  };
  cl.addtoman_chapter("CROSSOVER AND MUTATION",15,crossover);

  const std::string selection[15]={
    "Selection is specified using the follow operators:\n",
    "\\fBNPGA20p\\fR .TP Multiobjective evolutionary algorithm NPGA 2 (Niched Pareto Genetic Algorithm)\n\n",
    "\\fBSelectParsimonyTournOp\\fR .TP A simple lexicographic parsimony pressure tournament selection operator, based an idea presented in: Luke, S., and L. Panait. 2002. Lexicographic Parsimony Pressure.\n\n",
    "\\fBSelectRandomOp\\fR .TP Select an individual in a population randomly operator class (uniform distribution).\n\n",
    "\\fBSelectRouletteOp\\fR .TP Proportionnal roulette selection operator class.\n\n",
    "\\fBSelectTournamentOp\\fR .TP Tournament selection operator class.\n\n",
  };
  cl.addtoman_chapter("SELECTION",15,selection);

  const std::string term[15]={
    "Optimization is terminated using the following operators:\n\n",
    "\\fBTermMaxGenOp\\fR .TP Maximum generation termination criterion operator.\n\n",
    "\\fBTermMaxFitnessOp\\fR .TP Maximum fitness value termination criterion operator class.\n\n",
    "\\fBTermMaxHitsOp\\fR .TP Number of hits required in an individual in order for the evolution process to terminate.\n\n",
    "\\fBTermMaxEvalsOp\\fR .TP Maximum number of fitness evaluations termination criterion operator.\n\n"
  };
  cl.addtoman_chapter("TERMINATION",15,term);
  
  const std::string restart[5]={
    "Files output containing populations that can also be used for ",
    "continuing a simulation are generated with the following ",
    "operators. (See also POPULATION INITIALIZATION.)\n\n",
    "\\fBMilestoneWriteOp\\fR .TP Write out a milestone file\n\n",
    "\\fBParetoFrontCalculateOp\\fR .TP Evaluate Pareto front from demes and vivarium and put it in place of the actual hall-of-fame. The Pareto front is evaluated just before milestones are written. If previous hall-of-fame are presents in the demes/vivarium, they are erased. This operator must be in the evolver's operator sets between the termination criterion check operators and the MilestoneWriteOp operator.\n\n"
  };
  cl.addtoman_chapter("RESTART FILES AND POPULATION OUTPUT",5,restart);
  
  const std::string statistics[4]={
    "Statistics on fitness, function and terminal usage, and expression ",
    "tree size are generated using the follow operators:\n\n",
    "GP-StatsCalcFitnessSimpleOp, GP-StatsCalcFitnessKozaOp, ",
    "GP-PrimitiveUsageStatsOp, GP-IndividualSizeFrequencyStatsOp\n"
  };
  cl.addtoman_chapter("STATISTICS",4,statistics);

  const std::string adf[8]={
    "Automatically Defined Functions (ADF) and constrained operators ",
    "are also available:\n\n",
    "GP-ModuleCompressOp, GP-ModuleExpandOp, GP-CrossoverConstrainedOp, ",
    "GP-InitHalfConstrainedOp, GP-InitFullConstrainedOp, GP-InitGrowConstrainedOp, ",
    "GP-MutationShrinkConstrainedOp, GP-MutationStandardConstrainedOp, ",
    "GP-MutationSwapConstrainedOp, GP-MutationSwapSubtreeConstrainedOp.\n\n",
    "The additional primitives for the ADF operators include:\n\n",
    "ADF (Automatically Defined Function) and ARG (Generic Argument for ADF)\n"
  };
  cl.addtoman_chapter("ADF and Constrained Operators",8,adf);
    
  const std::string gp_func[6]={
    "The following functions can be utilized as primitives in the expression",
    ".TP Abs,Add,Cos,Divide,Exp,Log,Multiply,Sin,Subtract\n\n",
    "Additional functions added by PM-Dreamer are described ",
    "below. Functions are added by listing the function name ",
    "and bias in the primitive set. For example:\n\n",
    "      <Primitive name=\"ADD\" bias=\"1\"/>\n"
  };
  cl.addtoman_chapter("FUNCTIONS",6,gp_func);
  
  const std::string gp_prim[8]={
    "The terminals are primitives in the expression tree ",
    "that do not take arguments (e.g. constants in the ",
    "expression or variables of the expression. Some ",
    "that can be included are a double precision number ",
    "[-1, 1] (E), PI (Pi), and/or a variable, (X), for the potential:\n\n",
    "      <Primitive name=\"E\" bias=\"1\"/>\n",
    "      <Primitive name=\"Pi\" bias=\"1\"/>\n",
    "      <Primitive name=\"X\" bias=\"1\"/>\n"
  };
  cl.addtoman_chapter("TERMINALS",8,gp_prim);

  const std::string a_prim[7]={
    "The additional function and terminal primitives ",
    "have been added:\n\n ",
    "\\fBE_i\\fR .TP Double precision integer [-20,20]. ",
    "Generation or mutation of E_i results in an integer, however, ",
    "hybrid optimization can produce non-integer numbers.\n\n",
    "\\fBE_d\\fR .TP Double precision number [-20,20].\n\n",
    "\\fBPow\\fR .TP Exponentiation.\n"
  };
  cl.addtoman_chapter("ADDITIONAL PRIMITIVES",7,a_prim);
  
  const std::string regi[130]={
    "The registers allow for parameterization of the operators ",
    "and optimization (e.g. mutation frequency, number of generations, ",
    "etc.). The registers can be set by specifying the register ",
    "and the value in the configuration file:\n\n",
    "    <Entry key=\"ec.pop.size\">500/500/500/500</Entry>\n",
    "    <Entry key=\"ec.term.maxgen\">100</Entry>\n\n",
    "A list of registers and short descriptions is given below. ",
    "If the value type of a register begins with U, the type is unsigned. ",
    "If the value type is an array, individual elements are delimeted ",
    "using a /.\n\n"
    "\\fBec.conf.dump\\fR\t<String> (def: \"\") ",
    ".TP Filename used to dump the configuration. A configuration dump means that ",
    "a configuration file is written with the evolver (including the composing ",
    "operators) and the register (including the registered parameters and ",
    "their default values). No evolution is conducted on a configuration dump. ",
    "An empty string means no dump.\n\n",
    "\\fBec.elite.keepsize\\fR\t<UInt> (def: 1) ",
    ".TP Number of individuals keep as is with strong n-elitism.\n\n",
    "\\fBec.hof.demesize\\fR\t<UInt> (def: 0) ",
    ".TP Number of individuals kept in each deme's hall-of-fame (best individuals ",
    "so far). Note that a hall-of-fame contains only copies of the best ",
    "individuals so far and is not used by the evolution process.\n\n",
    "\\fBec.hof.vivasize\\fR\t<UInt> (def: 1) ",
    ".TP Number of individuals kept in vivarium's hall-of-fame (best individuals ",
    "so far). Note that a hall-of-fame contains only copies of the best ",
    "individuals so far and is not used by the evolution process.\n\n",
    "\\fBec.init.seedsfile\\fR\t<String> (def: \"\") ",
    ".TP Name of file to use for seeding the evolution with crafted individual. An ",
    "empty string means no seeding.\n\n",
    "\\fBec.mig.interval\\fR\t<UInt> (def: 1) ",
    ".TP Interval between each migration, in number of generations. An interval of ",
    "0 disables migration.\n\n",
    "\\fBec.mig.size\\fR\t<UInt> (def: 5) ",
    ".TP Number of individuals migrating between each deme, at a each migration.\n\n",
    "\\fBec.pop.size\\fR\t<UIntArray> (def: 100) ",
    ".TP Number of demes and size of each deme of the population. The format of an ",
    "UIntArray is S1,S2,...,Sn, where Si is the ith value. The size of the ",
    "UIntArray is the number of demes present in the vivarium, while each ",
    "value of the vector is the size of the corresponding deme.\n\n",
    "\\fBec.repro.prob\\fR\t<Float> (def: 0.1) ",
    ".TP Probability that an individual is reproducted as is, without ",
    "modification. This parameter is useful only in selection and ",
    "initialization operators that are composing a breeder tree.\n\n",
    "\\fBec.sel.tournsize\\fR\t<UInt> (def: 2) ",
    ".TP Number of participants for tournament selection.\n\n",
    "\\fBec.term.maxfitness\\fR\t<Float> (def: 1) ",
    ".TP Fitness value to reach before stopping evolution.\n\n",
    "\\fBec.term.maxgen\\fR\t<UInt> (def: 50) ",
    ".TP Maximum number of generations for the evolution.\n\n",
    "\\fBgp.cx.distrpb\\fR\t<Float> (def: 0.9) ",
    ".TP Probability that a crossover point is a branch (node with sub-trees). ",
    "Value of 1.0 means that all crossover points are branches, and value of ",
    "0.0 means that all crossover points are leaves.\n\n",
    "\\fBgp.cx.indpb\\fR\t<Float> (def: 0.9) ",
    ".TP Individual crossover probability at each generation.\n\n",
    "\\fBgp.init.maxargs\\fR\t<UIntArray> (def: 0/2) ",
    ".TP Maximum number of arguments in GP tree. Tree arguments are is usually ",
    "useful with ADFs (and similar stuff).\n\n",
    "\\fBgp.init.maxdepth\\fR\t<UInt> (def: 5) ",
    ".TP Maximum depth for newly initialized trees.\n\n",
    "\\fBgp.init.maxtree\\fR\t<UInt> (def: 1) ",
    ".TP Maximum number of GP tree in newly initialized individuals. More than one ",
    "tree is usually useful with ADFs (and other ADx).\n\n",
    "\\fBgp.init.minargs\\fR\t<UIntArray> (def: 0/2) ",
    ".TP Minimum number of arguments in GP tree. Tree arguments are is usually ",
    "useful with ADFs a(nd similar stuff).\n\n",
    "\\fBgp.init.mindepth\\fR\t<UInt> (def: 2) ",
    ".TP Minimum depth for newly initialized trees.\n\n",
    "\\fBgp.init.mintree\\fR\t<UInt> (def: 1) ",
    ".TP Minimum number of GP tree in newly initialized individuals. More than one ",
    "tree is usually useful with ADFs (and other ADx).\n\n",
    "\\fBgp.mutephdbl.indpb\\fR\t<Float> (def: 0.05) ",
    ".TP Probability of mutating a terminal constant by ",
    "GP-MutationEphemeralDoubleOp.\n\n",
    "\\fBgp.mutephdbl.primit\\fR\t<String> (def: E) ",
    ".TP Name of the primitive mutated by GP-MutationEphemeralDoubleOp.\n\n",
    "\\fBgp.mutshrink.indpb\\fR\t<Float> (def: 0.05) ",
    ".TP Shrink mutation probability for an individual. Shrink mutation consists ",
    "in replacing a branch (a node with one or more arguments) with one of his ",
    "child node. This erases the chosen node and the other child nodes.\n\n",
    "\\fBgp.mutstd.indpb\\fR\t<Float> (def: 0.05) ",
    ".TP Standard mutation probability for an individual. A standard mutation ",
    "replaces a sub-tree with a randomly generated one.\n\n",
    "\\fBgp.mutstd.maxdepth\\fR\t<UInt> (def: 5) ",
    ".TP Maximum depth for standard mutation. A standard mutation replaces a ",
    "sub-tree with a randomly generated one.\n\n",
    "\\fBgp.mutswap.distrpb\\fR\t<Float> (def: 0.5) ",
    ".TP Probability that a swap mutation point is a branch (node with sub-trees). ",
    "Value of 1.0 means that all swap mutation points are branches, and value ",
    "of 0.0 means that all swap mutation points are leaves. Swap mutation ",
    "consists in exchanging the primitive associated to a node by one having ",
    "the same number of arguments.\n\n",
    "\\fBgp.mutswap.indpb\\fR\t<Float> (def: 0.05) ",
    ".TP Swap mutation probability for an individual. Swap mutation consists in ",
    "exchanging the primitive associated to a node by one having the same ",
    "number of arguments.\n\n",
    "\\fBgp.tree.maxdepth\\fR\t<UInt> (def: 17) ",
    ".TP Maximum allowed depth for the trees.\n\n",
    "\\fBgp.try\\fR\t<UInt> (def: 2) ",
    ".TP Maximum number of attempts to modify a GP tree in a genetic operation. As ",
    "there is topological constraints on GP trees (i.e. tree depth limit), it ",
    "is often necessary to try a genetic operation several times.\n\n",
    "\\fBlg.file.level\\fR\t<UInt> (def: 3) ",
    ".TP Log level used for file output generation. Log levels available are: (0) ",
    "no log, (1) basic logs, (2) stats, (3) general informations, (4) details ",
    "on operations, (5) trace of the algorithms, (6) verbose, (7) debug ",
    "(enabled only in full debug mode).\n\n",
    "\\fBlg.show.class\\fR\t<Bool> (def: 0) ",
    ".TP Flag whether class name is outputed in the logs.\n\n",
    "\\fBlg.show.level\\fR\t<Bool> (def: 0) ",
    ".TP Flag whether logging level in outputed in the logs.\n\n",
    "\\fBlg.show.type\\fR\t<Bool> (def: 0) ",
    ".TP Flag whether message type is outputed in the logs.\n\n",
    "\\fBms.restart.file\\fR\t<String> (def: \"\") ",
    ".TP Name of the milestone file from which the evolution should be restarted. ",
    "An empty string means no restart.\n\n",
    "\\fBms.write.compress\\fR\t<Bool> (def: 1) ",
    ".TP If true, this flag indicates that milestones will be compressed with ",
    "gzip. Otherwise, each milestone are kept plain text.\n\n",
    "\\fBms.write.interval\\fR\t<UInt> (def: 0) ",
    ".TP Milestone saving interval (in number of generations). When zero, only the ",
    "last generation milestone is saved.\n\n",
    "\\fBms.write.over\\fR\t<Bool> (def: 1) ",
    ".TP If true, this flag indicates that old milestones should be over-written. ",
    "Otherwise, each milestone has a different suffix.\n\n",
    "\\fBms.write.perdeme\\fR\t<Bool> (def: 0) ",
    ".TP If true, this flag indicates that separate milestones should be written ",
    "after each demes processing. Otherwise milestones are written after the ",
    "processing of a complete populations.\n\n"
  };
  cl.addtoman_chapter("REGISTERS",61,regi);


  const std::string pair[123]={
    "The fitness evaluation in PM-Dreamer can be calculated using several ",
    "different fitness statistics specified with the -s flag. The fitness ",
    "in each case is given by \\fIF\\fR:\n\n",
    ".EQ F ~=~ 1 over {1 ~+~ c times s ( bold e , bold p )} .EN \n\n",
    "where \\fBe\\fR represents the energies and/or forces from the training ",
    "set normalized by the number of distances used in the calculation of each ",
    "energy/force and \\fBp\\fR represents those normalized values as ",
    "calculated by a candidate individual. ",
    "For the adaptive RMSD, \\fIc\\fR=1 and \\fIs\\fR(\\fBe\\fR,\\fBp\\fR) ",
    "is the normalized root mean squared error between \\fBe\\fR and \\fBp\\fR. For the ",
    "Pearson correlation coefficient, \\fIc\\fR=100 and \\fIs\\fR is given ",
    "by the absolute value of the correlation coefficient between ",
    "\\fBe\\fR and \\fBp\\fR. For OLS, ordinary least squares is performed ",
    "to give the linear rescaling of \\fBp\\fR that results in the lowest ",
    "RMSD with \\fBe\\fR. For 3-body potentials, the least squares problem ",
    "is solved to optimize the linear combination of the 2 and 3 body ",
    "functions that optimize the fit. In this case, \\fIs\\fR is this RMSD and ",
    "\\fBc\\fR is 1. When using the Pearson correlation or OLS, ",
    "the functions must be post-processed to minimize the RMSD by solving ",
    "analytically for new constants in the expression tree. This can be ",
    "accomplished using \\fBOLSCorrectOp\\fR or \\fBDreamerOp\\fR as described ",
    "below. The calculation of \\fBp\\fR according to the ",
    "candidate expression is performed using one of several templates ",
    "specified with the -t option. For all, the fitness calculation ",
    "in the beagle_config_file file is specified using \\fBEnergyOp\\fR.\n\n",
    
    "\n\\fBPAIR POTENTIALS\\fR (\\fI-t pair\\fR)\n\n",
    "The pair potential, \\fBpair\\fR, is the default functional ",
    "form used for fitness calculation. It is calculated as:\n\n ",
    ".EQ p ~=~ 1 over n sum from i=1 to n ~g ~( X sub i ) .EN \n\n",
    "where \\fIX_i\\fR is a single variable describing the particle pair ",
    "(e.g. the inter-particle distance) and \\fIg\\fR is the function ",
    "optimized using genetic programming. The fitness of ",
    "the function is evaluated using a ",
    "set of sample configurations for which the energies have been ",
    "calculated. For example input file formats, see \\fIpair\\fR and ",
    "\\fIefxyz\\fR below. In order to ",
    "use this template, the X variable should be added to the primitive ",
    "set:\n\n",
    "\t<Primitive name=\"X\"   bias=\"1\"/>\n\n",

    "\\fBPAIR POTENTIALS WITH FORCE\\fR (\\fI-t paird\\fR)\n\n",
    "The pair potential with force, \\fBpaird\\fR, is similar to \\fBpair\\fR ",
    "with the exception that a particle force is supplied for a particle ",
    "in each configuration allowing the potential function to be fit ",
    "to both the energy and the force. When this style is used ",
    "the fitness is one half the fitness statistic calculated for the energies ",
    "plus one half the fitness statistic calculated for the forces.\n\n",
    
    "When OLS is used as a fitness statistic, the least squares optimization ",
    "is performed using only the energies - the force calculation is performed ",
    "using the resulting formula. The Pearson correlation is calculated ",
    "separately for the energies and forces - therefore it might not be possible ",
    "to 'correct' the equations with a single set of optimized coefficients.\n\n",
    
    "Here, the potential is calculated as described for the \\fBpair\\fR ",
    "style, and the force is calculated as the negative gradient of the ",
    "energy for a particle using forward finite-difference. ",
    "This style requires an input format that supports forces; for an ",
    "example, see efxyz below. The ",
    "equations that result from the optimization will be in terms of ",
    "the independent variable \\fIX\\fR which represents the ",
    "interparticle distance for a pair as calculated from the ",
    "supplied positions. Therefore, \\fIX\\fR should be added ",
    "to the primitive set as described for \\fBpair\\fR.\n\n",
    
    "\\fBPAIR POTENTIAL USING ONLY THE FORCE\\fR (\\fI-t pairf\\fR)\n\n",
    "This template is similar to \\fBpaird\\fR with the difference ",
    "that only the forces are used in fitness evaluation. This style ",
    "can therefore allow for much faster optimization followed by ",
    "refinement by switching to style \\fBpaird\\fR. ",
    "Any energies specified in the input file are ignored.\n\n",
    
    "\\fBPAIR POTENTIAL USING ONLY THE X-FORCE\\fR (\\fI-t pairf1\\fR)\n\n",
    "This template is similar to \\fBpairf\\fR except that only the ",
    "x component of the force is utilized for fitness evaluation.\n\n",
    
    "\\fBTWO/THREE BODY POTENTIALS\\fR (\\fI-t twothree\\fR)\n\n",
    "This template evaluates two summations for the potential energy ",
    "and can be used to fit potentials that include a 2-body term ",
    "and a 3-body term. The form for the expression is:\n\n",
    ".EQ p ~=~ 1 over n sum from i to n ~g ~( X sub i ) ~+~ 1 over n ",
    "sum from i to m ~h ~( R1 sub i , R2 sub i, A sub i ) .EN \n\n",
    "The sample data therefore consists of a set variables \\fIX_1\\fR,",
    "...,\\fIX_n\\fR that are evaluated in the first summation and a second ",
    "set \\fIR1_1\\fR,...,\\fIR1_m, \\fIR2_1\\fR,...,\\fIR2_m, and ",
    "\\fIA_1\\fR,...,\\fIA_m\\fR that are evaluated in the second summation, ",
    "where \\fIn\\fR is not necessarily equal to \\fIm\\fR. For a 2/3-body ",
    "potential, \\fIX\\fR might represent the interparticle distances ",
    "in the 2-body part of the potential. For the 3-body part, ",
    "\\fIR1\\fR and \\fIR2\\fR might represent the distances from particle 1 ",
    "to particles 2 and 3 and \\fIA\\fR might represent the angle cosine ",
    "between the corresponding vectors. Example input data file formats ",
    "for this style include \\fItwothree\\fR and \\fIefxyz\\fR (below). ",
    "In order to use this style, the variables X, R1, R2, and A must be added to ",
    "the primitive set:\n\n",
    "\t<Primitive name=\"X\"   bias=\"1\"/>\n",
    "\t<Primitive name=\"R1\"  bias=\"1\"/>\n",
    "\t<Primitive name=\"R2\"  bias=\"1\"/>\n",
    "\t<Primitive name=\"A\"   bias=\"1\"/>\n\n",
    "The equations for \\fIg\\fR and \\fIh\\fR are stored in the ",
    "same expression tree where \\fIg\\fR is the left subtree of ",
    "the root node and \\fIh\\fR is the right subtree of the ",
    "root node. For this template, the root node is meaningless.\n\n",

    "\\fBTWO/THREE BODY POTENTIALS WITH FORCE\\fR (\\fI-t twothreed\\fR)\n\n",
    "This template evaluates the \\fBtwothree\\fR potential style, but also ",
    "evaluates the force for a single particle in each configuration in the fitness ",
    "function. This is done in an identical manner to the \\fBpaird\\fR ",
    "potential style. Using the ",
    "cutoff and particle positions, the vector \\fBX\\fR is calculated ",
    "to contain all particle pairwise distances smaller than the cutoff. ",
    "Likewise, for all particle triplets, the vectors \\fBR1\\fR, \\fBR2\\fR ",
    "and \\fBA\\fR are calculated to contain the distances between the center ",
    "atom and the other two atoms and the angle cosine between ",
    "the corresponding vectors ",
    "if the two distances are both smaller than the cutoff. As with the other ",
    "twothree styles, the variables X, R1, R2, and A should be added to ",
    "the primitive set.\n\n",

    "As with paird, when OLS is used as a fitness ",
    "statistic, the least squares optimization ",
    "is performed using only the energies - the force calculation is performed ",
    "using the resulting formula. The Pearson correlation is calculated ",
    "separately for the energies and forces - therefore it might not be possible ",
    "to 'correct' the equations with a single set of optimized coefficients.\n\n",
    
    "\\fBTWO/THREE BODY POTENTIALS USING ONLY FORCE\\fR (\\fI -t twothreef\\fR)\n\n",
    "This template is similar to \\fBtwothreed\\fR with the exception that only ",
    "the force is used in the fitness evaluation. This allows for potentially ",
    "faster optimizations and can be used to seed further runs that use ",
    "the \\fBtwothreed\\fR style. Any energies in the input data files are ",
    "ignored."
  };
  cl.addtoman_chapter("FITNESS EVALUATION",123,pair);
  
  const std::string data[78]={
    "Several data file types are supported for specifying the energies and/or ",
    "forces along with configuration data: \n\n",
    "\\fBEFXYZ Data File Type\\fR\n\n",
    "This data type supports configuration data in the form of atom positions ",
    "with an option for periodic boundary conditions and a cutoff. Exactly 1 ",
    "energy and 1 particle force are supplied per configuration. Zero(s) can ",
    "be used in place of the energy or force if unknown and not used in  ",
    "the optimization (see fitness evaluation above). The file type supports ",
    "only 1 particle type. The format for the input data file is: \n\n",
    "\t# Comments for the input file\n\n",
    "\tfiletype efxyz\n",
    "\tcutoff \\fIC\\fR\n",
    "\tperiodic \\fIp_x p_y p_z\\fR\n\n",
    "\t.EQ e \" \" f sub i \" \" f sub x \" \" f sub y \" \" f sub z \" \" ",
    "x sub 1 \" \" y sub 1 \" \" z sub 1 \" \" x sub 2 \" \" y sub 2 \" \" ",
    "z sub 2 \" ...\" .EN\n",
    "\t...\n\n",
    "First a cutoff is specified such that particle pairs with a distance ",
    "greater than \\fIC\\fR contribute zero to the force and energy ",
    "calculation. If \\fIC\\fR is negative, the cutoff is infinity. ",
    "If the periodic keyword is present, periodic boundary conditions ",
    "are used with box dimensions equal to \\fIp_x\\fR, \\fIp_y\\fR ",
    "and \\fIp_z\\fR. ",
    "Each of the following lines begins with an energy \\fIe\\fR ",
    "followed by an index to a particle for which the force is computed, ",
    "\\fIf_i\\fR. The first particle index is 1. This is followed by the ",
    "Cartesian components of the force. Finally the Cartesian ",
    "coordinates for each particle in the system are given.\n\n",

    "\\fBEFIXYZ Data File Type\\fR\n\n",
    "This file is similar to the efxyz format except that multiple particle ",
    "types can be specified:\n\n",
    "\t# Comments for the input file\n\n",
    "\tfiletype efixyz\n",
    "\tcutoff \\fIC\\fR\n",
    "\tperiodic \\fIp_x p_y p_z\\fR\n\n",
    "\ttypes \\fIN\\fR\n",
    "\t.EQ e \" \" f sub i \" \" f sub x \" \" f sub y \" \" f sub z \" \" ",
    "i sub 1 \" \" x sub 1 \" \" y sub 1 \" \" z sub 1 \" \" i sub 2 \" \" ",
    "x sub 2 \" \" y sub 2 \" \" ",
    "z sub 2 \" ...\" .EN\n",
    "\t...\n\n",
    "where \\fIN\\fR is the number of particle types and \\fIi\\fR is the ",
    "type for each particle. The valid range for particle types is ",
    "[1..\\fIN\\fR]. See the multiple particle types section for more ",
    "information on performing these types of optimizations.\n\n",
    
    "\n\\fBPAIR Data File Type\\fR\n\n",
    "The pair file type supports configuration input in terms of an ",
    "energy and a single variable, X, that the potential is summed over to ",
    "calculate an energy (e.g. X can be the interatomic distance used ",
    "to compute the energy). The file type only supports 1 particle type for ",
    "configurations and only 2-body potentials. Additionally, fitness ",
    "evaluation is limited to templates that do not use particle forces. ",
    "The format for the input file is: \n\n ",
    "\t# Comments for the input file\n\n",
    "\tfiletype pair\n\n",
    "\t.EQ e \" \" X sub 1 \" \" X sub 2 \" ...\" .EN\n",
    "\t.EQ e \" \" X sub 1 \" \" X sub 2 \" ...\" .EN\n",
    "\t...\n\n",
    "Each line begins with an energy \\fIe\\fR and is followed by a ",
    "variable number of data points for each pair in the configuration. ",
    "Empty lines and lines beginning with # are ignored.\n\n",
    
    "\\fBTWOTHREE Data File Type\\fR\n\n",
    "This file type is used for potentials that perform a summation ",
    "of some function over all pairs and a separate summation over ",
    "all triplets. The template allows for a single variable, X, in ",
    "the two-body equation (e.g. interatomic distance), and 3 variables ",
    "(R1, R2, and A) for the 3-body equation (e.g. interatomic distances ",
    "and triplet angle). The file type only supports 1 particle type and ",
    "can only be used with 3-body fitness evaluation. Additionally, fitness ",
    "evaluation is limited to templates that do not use particle force. ",
    "The format for the input data file is:\n\n",
    "\t# Comments for the input file\n\n",
    "\tfiletype twothree\n\n",
    "\t.EQ e \" \" bold TWO \" \" X sub 1 \" ... \" X sub n \" \" ",
    "bold THREE \" \" R1 sub 1 \" \" R2 sub 1 \" \" A sub 1 \" ... \"",
    "R1 sub m \" \" R2 sub m \" \" A sub m .EN\n",
    "\t...\n\n",
    "where \\fIe\\fR is the energy of the configuration."
  };
  cl.addtoman_chapter("DATA FILE TYPES",78,data);

  const std::string mpi[122]={
    "PM-Dreamer can be run in parallel using an island model. In serial, ",
    "PM-Dreamer uses the Open Beagle model allowing for multiple populations ",
    "with individual movement according to migration operators. In parallel ",
    "PM-Dreamer allows for multiple islands, 1 per process, to be run. ",
    "Each island can contain multiple populations with migration controlled ",
    "by the standard operators. Migration between the islands is controlled ",
    "by additional operators which are described below. The output for each ",
    "island is written separately to the files gp_force_0.log, ",
    "gp_force_1.log, ... and gp_force_0.obm(.gz), gp_force_1.obm(.gz), ... ",
    "It should be noted that in the current implementation, random seeds "
    "only produce the same output when run on the same number of processors. ",
    "When running in parallel, the MPITerminateOp should be used to ",
    "to assure proper termination of all processes in a run. ",
    "The additional operators available for parallel execution are:\n\n",

    "\\fBMigrationMPIOp\\fR .TP Each time \\fIec.mig.mpi_interval\\fR ",
    "generations passes, \\fIec.mig.mpi_size\\fR individuals from each ",
    "population on an island migrate to a randomly chosen island and ",
    "are replaced with immigrants from a second randomly chosen island. ",
    "The random islands are chosen such that all islands will participate ",
    "in migration at each iteration. The operator does not perform ",
    "migration between populations on the same island. This can ",
    "be achieved using standard migration operators in addition to ",
    "MigrationMPIOp\n\n",
    
    "\\fBHFCompMPIOp\\fR .TP This implements a distributed parallel ",
    "algorithm for the Hierarchical Fair Competition inspired ",
    "by the work of Hu and Goodman. (Similar to the serial ",
    "HierarchicalFairCompetitionOp). This operator should not be used ",
    "with the serial HierarchicalFairCompetitionOp operator. In this ",
    "algorithm, a fitness threshold is chosen such that any individuals ",
    "from a population with index \\fIi\\fR will migrate to the ",
    "population \\fIi\\fR+1 if their fitness is better than the fitness ",
    "threshold for that population \\fIi\\fR+1. If any populations ",
    "has excess individuals following migration, the least fit individuals ",
    "are killed off. Random individuals are added to account ",
    "for any shortages. This promotes a ",
    "hierarchy of populations where the fitness of the best individuals ",
    "improves with the population index. The migration occurs through ",
    "all populations on a single island followed by migration of individuals ",
    "of the last population of one island to the first population of another. ",
    "In order to achieve parallel efficiency, their is a ",
    "1-step lag from the time individuals migrate out of an island ",
    "to the time they arrive at the next. The fitness thresholds for the ",
    "populations can be set in 2 ways. In the default, ec.hfc.first is ",
    "set to -1 and the fitness threshold for a population is set to a ",
    "value where the threshold is greater than ec.hfc.percentile of ",
    "the population. For example, if ec.hfc.percentile is 0.85 ",
    "the fitness threshold for a population is set to the value of the ",
    "individual whose fitness is worse than only 15% of the population. ",
    "In the case, the fitness thresholds are adaptive. ",
    "In the second approach, the fitness thresholds are fixed. ",
    "ec.hfc.first (float greater than 0 ",
    "and less than 1) is set to the fitness threshold of the first ",
    "population accepting incoming individuals. The thresholds for the ",
    "subsequent populations are increased according to ec.hfc.scale (described below)",
    "to allow for thresholds up to but less than 1.0\n\n",
    
    "\\fBGP-StatsCalcFitSimpleMPIOp\\fR .TP This operator can replace ",
    "GP-StatsCalcFitnessSimpleOp to replace Vivarium statistics for a ",
    "single island with Vivarium statistics for all processes in the ",
    "log file on process 0. The best hall-of-fame individual from ",
    "all processes is also stored in the milestone file for process 0. ",
    "When using this operator, analysis of the log file generated ",
    "on process 0 should be all that is necessary under most circumstances. ",
    "This operator will also output fitness information and a \"pretty\" ",
    "representation of the best individual at each generation to stdout.\n\n",
    
    "\\fBMPITerminateOp\\fR .TP This signals the application to terminate ",
    "execution of all processes whenever a single island is terminated ",
    "by any of the termination operators. This operator also delays ",
    "termination until all demes are evaluated for a given generation. ",
    "This allows proper communication of statistics and end-of-run ",
    "operations such as simplification and OLS correction to occur ",
    "In order to work properly, the operator should be placed following ",
    "any other termination operators.\n\n",

    "\\fBTermMaxTimeOp\\fR .TP Terminate after ec.term.maxtime minutes ",
    "have passed. If compiled with MPI, this is the MPI wall time. ",
    "Otherwise, this is the time calculated using c_time clock(). ",
    "If set to zero, the operator is ignored. This operator will ",
    "also log the time at each generation to stdout\n\n",

    "The registers available for parallel execution are:\n\n",
    "\\fBec.mig.mpi_interval\\fR .TP The number of generations that must pass ",
    "before a migration between islands occurs.\n\n",
    "\\fBec.mig.mpi_size\\fR .TP The number of individuals that migrate from each ",
    "population of each island.\n\n",
    "\\fBec.term.maxtime\\fR .TP Terminate the evolution after this many ",
    "minutes (default 60).\n\n",
    "\\fBec.hfc.percentile .TP Percentile of fitness measure to use as HFC ",
    "migration threshold of next population. For example, a threshold of 0.85 ",
    "means that the fitness used as threshold to accept migrant into ",
    "following population is taken as the fitness of the individual that ",
    "is better than 85% of the other individuals in its population. ",
    "Default is 0.85. This value is ignored if ec.hfc.first is positive\n\n",
    "\\fBec.hfc.first .TP If negative, adaptive thresholds are used for HFC ",
    "according to ec.hfc.percentile. If positive, the register must be ",
    "greater than 0 and less than 1.0. The thresholds for the populations ",
    "in HFC are then set evenly spaced fixed values between \\fIfirst\\fR ",
    "and 1.0.\n\n",
    "\\fBec.hfc.scale\\fR .TP This parameter is used to adjust how the ",
    "fitness thresholds of populations are scaled if adaptive thresholds ",
    "are not used (ec.hfc.first>0). The ratio between the fitness thresholds ",
    "of populations is given by ec.hfc.scale to create a geometric series ",
    "between ec.hfc.first and 1.0. If ec.hfc.scale is 1, the fitness ",
    "thresholds are evenly spaced. If ec.hfc.scales is >1, more of the ",
    "fitness thresholds are at lower fitnesses. If <1, more are at ",
    "higher fitnesses. The default value is 1.\n\n",
    "\\fBec.hfc.interval\\fR .TP Interval between each hierarchical fair ",
    "competition migration, in number of generations. An interval of 0 ",
    "disables HFC migrations. Default is 1.\n\n",
    "\\fBec.hfc.copy_num\\fR .TP This flag controls the number of islands ",
    "that have the same fitness thresholds. For example, a 4 processor job ",
    "can have fitness thresholds of {0, 0.25, 0.5, 0.75} when copy_num is 1 ",
    "or fitness thresholds of {0, 0, 0.5, 0.5} when copy_num is 2. ",
    "For the latter case, an individual on island 0 or 1 who exceeds the ",
    "fitness threshold of 0.5 will migrate to either population 3 or 4 ",
    "randomly. When copy number is greater than 1, migration between ",
    "islands with the same fitness threshold can be allowed with the ",
    "use of MigrationMPIOp and a ec.mig.mpi_split register value equal ",
    "to copy_num. This register can also be set from the command line. ",
    "Default is 1.\n\n",
    "\\fBec.mig.mpi_split\\fR .TP When this register is greater than 1, ",
    "the islands are split into groups of size ec.mig.mpi_split. Each group ",
    "contains a sequential ordering of islands according to process rank. ",
    "Migration according to the MigrationMPIOp will then only occur within ",
    "a group. This can be used with HFCCompMPIOp to restrict migration only ",
    "between populations with the same fitness threshold. Default is 0\n"
  };
  cl.addtoman_chapter("PARALLEL PM-DREAMER",122,mpi);
  
  const std::string hybrid[39]={
    "PM-Dreamer supports hybrid optimization of functional forms, allowing ",
    "for local optimization of constants in the expression tree. This ",
    "is accomplished by adding the \\fBGP-HybridOptOp\\fR operator. The registers ",
    "that parameterize the operator include:\n\n",
    "\\fBgp.hybopt.indpb\\fR .TP The frequency with which hybrid optimization ",
    "is performed on an indivual. The default value is 0.05.\n\n",
    "\\fBgp.hybopt.primit\\fR .TP The name for the constants in the tree ",
    "that are optimized. Default is E.\n\n",
    "\\fBgp.hybopt.type\\fR .TP The type of optimization to be performed. ",
    "If the value is 0, all constants in an expression tree are optimized ",
    "using multidimensional Nelder/Mead Simplex algorithm. If the value ",
    "is nonzero, a random constant in the expression tree is optimized ",
    "using 1D minimization (also with Simplex). The default value is 1.\n\n",
    "\\fBgp.hybopt.maxi\\fR .TP The maximum number of iterations of ",
    "local optimization to be performed. Default is 10.\n\n",
    "\\fBgp.hybopt.simplify\\fR .TP If nonzero, function simplification is ",
    "performed before each optimization. See SimplifyOp. Default is 0.\n\n",
    "\\fBgp.hybopt.mtypes\\fR .TP If nonzero, optimization is also performed ",
    "on the E_p and E_t constants used for multiple particle types. ",
    "See MULTIPLE PARTICLE TYPES section below for more details. ",
    "Default is 1.\n\n",
    "Please see Function Simplification for additional registers that control ",
    "simplification during hybrid optimization.\n\n",
    "An analytic optimization is also available that utilizes least squares ",
    "for function optimization. For a 2-body potential function \\fIf\\fR ",
    "the function is modified to give \\fIf'\\fR=\\fIaf+b\\fR where \\fIa\\fR ",
    "and \\fIb\\fR are optimized to result in the lowest RMSD. For a 3-body ",
    "potential \\fIf+g\\fR, four constants are optimized to give ",
    "\\fIaf+b+cg+d\\fR. This is accomplished with the \\fBGP-OLSCorrectOp\\fR ",
    "operator. Because this operator increases the function size at each ",
    "operation, it is recommended that it only be performed once (e.g. at the ",
    "end of a run). \\fBDreamerOp\\fR described below is one way to accomplish ",
    "this. The registers for \\fBGP-OLSCorrectOp\\fR are:\n\n",
    "\\fBgp.olscorrect.name\\fR .TP The name of the primitives added that ",
    "store constant values. Default is E.\n\n",
    "\\fBgp.olscorrect.indpb\\fR .TP The probability of operation on an "
    "individual. Default is 1.0\n\n",
    "\\fBgp.olscorrect.interval\\fR .TP The interval in generations between "
    "operations. Default is 20\n\n"
  };
  cl.addtoman_chapter("HYBRID PM-DREAMER",39,hybrid);
  
  const std::string simplify[29]={
    "PM-Dreamer supports function simplification to reduce tree size. ",
    "This is accomplished by evaluating each non-terminal node of the tree for the ",
    "set of input values. If the range of answers for the set of ",
    "evaluations is smaller than a specified threshold, the subtree ",
    "is replaced with a constant value. Likewise, if a subtree ",
    "evaluates to be identical to an input variable, it is replaced with ",
    "that variable. This is accomplished by adding the \\fBGP-SimplifyOp\\fR ",
    "operator. The registers that parameterize the operator include:\n\n",
    "\\fBgp.simplify.indpb\\fR .TP The frequency with which simplification ",
    "is performed on an indivual. The default value is 1.0.\n\n",
    "\\fBgp.simplify.name\\fR .TP The name of the ephemeral for constants ",
    "used to replace subtrees. Default is E.\n\n",
    "\\fBgp.simplify.eps\\fR .TP The threshold for determining invariance. ",
    "The default is 1e-20.\n\n",
    "\\fBgp.simplify.maxe\\fR .TP The maximum number of evaluations used ",
    "to determine invariance. The evaluations are performed using the ",
    "same input data that is used for fitness evaluation. If 0, ",
    "all input data are used. Otherwise, the first maxe function evaluations ",
    "are performed. The default is 0.\n\n",
    "\\fBgp.simplify.interval\\fR .TP Interval in generations between each ",
    "simplification operation. An interval of 0 disables simplification. ",
    "Default is 20.\n\n",
    "You can also perform simplification on an individual before hybrid ",
    "optimization. In this case, the <GP-SimplifyOp> operator does not ",
    "need to be specified explicitly in the configuration file. However ",
    "the registers that control simplification should still be specified ",
    "(aside from gp.simplify.indpb which is not used).\n"
  };
  cl.addtoman_chapter("FUNCTION SIMPLIFICATION",29,simplify);
  
  const std::string dreamerop[26]={
    "The Dreamer operator \\fBDreamerOp\\fR is utilized to perform ",
    "post-processing of the best individual from a run. ",
    "Additionally, the operator includes the functions of \\fBMPITerminateOp\\fR ",
    "and \\fBGP-StatsCalcFitSimpleMPIOp\\fR. At the end of a run ",
    "the best individual is simplified (\\fBGP-SimplifyOp\\fR) and ",
    "optimized (\\fBGP-HybridOptOp\\fR) using the user-specified fitness statistic. ",
    "OLS optimization is then performed (\\fBGP-OLSCorrectOp\\fR). ",
    "This is followed by a second round of simplification and optimization ",
    "using AdaptiveRMSD as the fitness statistic. For parallel runs, "
    "the best individual from all processes is moved to the hall-of-fame ",
    "on process 0. The user-specified fitness, functional form, and RMSD ",
    "for the energies and/or forces is reported. As with ",
    "\\fBGP-StatsCalcFitSimpleMPIOp\\fR, this function will add monitoring ",
    "of the fitness and functional form of the best individual during the ",
    "run. Because the operator incorporates \\fBMPITerminateOp\\fR, ",
    "it should be placed following any other termination operators. ",
    "The following registers (described above) can be specified when ",
    "using \\fBDreamerOp\\fR: \\fIgp.simplify.name, gp.simplify.eps, ",
    "gp.simplify.maxe, gp.olscorrect.name, gp.hybopt.primit\\fR. ",
    "\\fBgp.hybopt.type\\fR is set to 0 and gp.hybopt.maxi is set to 100 ",
    "when performing optimization \\fIwithin\\fR \\fBDreamerOp\\fR. ",
    "\\fBGP-StatsCalcFitSimpleMPIOp\\fR and \\fBMPITerminateOp\\fR ",
    "do not need to be specified in the input parameter file when ",
    "using \\fBDreamerOp\\fR. \\fBGP-HybridOptOp\\fR and \\fBGP-SimplifyOp\\fR ",
    "should be specified if you wish to perform these operations during the ",
    "run.\n"
  };
  cl.addtoman_chapter("DREAMER OPERATOR",26,dreamerop);

  const std::string restartd[16]={
    "Simulations can be restart using the -c flag. This requires that ",
    "the ReadRestartOp operator be present in the beagle_config_file. ",
    "The ReadRestartOp replaces the MilestoneReadOp in OpenBeagle. ",
    "When restarting, the individuals and the generation number ",
    "are read. The data, template_style, and parameters from the ",
    "previous run are not read in. This allows the user to continue ",
    "a run with new data, template_style, and/or configuration parameters. ",
    "When restarting a run with new data or a new template_style, the ",
    "fitness of all individuals are recalculated and the Hall of Fame ",
    "individuals are updated with any changes that result from the ",
    "new fitness evaluation. Because the restart will start using the ",
    "last generation from the milestone files, the ec.term.maxgen ",
    "register may need to be increased to allow for a larger number ",
    "of generations. When restarting in parallel, if a smaller ",
    "number of processors is used, the individuals from the higher ",
    "rank processes will be thrown out."
  };
  cl.addtoman_chapter("RESTARTING OPTIMIZATIONS",16,restartd);
  
  const std::string vectorized[16]={
    "PM-Dreamer allows for vectorized evaluation of expression trees ",
    "(which is now the default). Vectorization can be disabled by ",
    "using the -z flag. When vectorization is enabled, the expression tree ",
    "for a given individual needs to be parsed only a single time using ",
    "the vector(s) of values necessary for energy/force calculation. ",
    "This provides an improvement in speed because it prevents multiple ",
    "parsing of the same expression tree and the potential for SIMD ",
    "compiler optimizations. The configuration file does not need to be changed ",
    "to utilize vectorization; internal replacements of the standard ",
    "primitives and fitness operators are performed to allow vector math ",
    "operations to be performed. Although the runs with vectorization ",
    "should produce identical results, changes due to finite precision ",
    "and the order of summation operations can result in different results. ",
    "Because certain Open Beagle primitives have the argument types hard-coded, ",
    "vectorization is left as an option to aid in compatability with future ",
    "versions."
  };
  cl.addtoman_chapter("VECTORIZATION",16,vectorized);
 
  const std::string mtypes[61]={
    "PM-Dreamer allows for optimization using multiple particle types ",
    "as specified with the \\fBefixyz\\fR file format. Output is given to standard ",
    "out at the beginning of a simulation with the number of interactions ",
    "for each combination of particle types (for example):\n\n",
    "\tPair_Particle_Type Count\n",
    "\t------------------------\n",
    "\t1-1 77\n", 
    "\t2-1 154\n", 
    "\t2-2 69\n", 
    "\t\n",
    "\t3body_Particle_Type Count (Center First)\n",
    "\t----------------------------------------\n",
    "\t1-1-1 33\n", 
    "\t1-2-1 88\n", 
    "\t1-2-2 33\n", 
    "\t2-1-1 44\n", 
    "\t2-2-1 66\n", 
    "\t2-2-2 36\n\n",
    "Optimization using multiple particle types requires the addition of ",
    "special primitives in order to be effective. For 2-body potentials, ",
    "E_p can be added to optimize constants for each particle type ",
    "interaction:\n\n",
    "\t<Primitive name=\"E_p\" bias=\"1\"/>\n\n",
    "The primitive E_p will be described in any equation as a vector ",
    "of constants in the same order as the type counts written at the ",
    "beginning of the optimization. ",
    "For 3-body combinations, the primitive E_t can also be added:\n\n",
    "\t<Primitive name=\"E_t\" bias=\"1\"/>\n\n",
    "In equations written to standard out, each occurance of an E_p or ",
    "E_t primitive is replaced with a lower case variable (starting with ",
    "the letter a). The vector corresponding to each variable is written ",
    "on the following lines (for example):\n\n",
    "\t  2-Body: (a*X)/1.7441+b\n",
    "\t          a=[-4.0801 -14.4792 -16.8834]\n",
    "\t          b=[-8.4213 -21.0239 253.8123]\n",
    "\t  3-Body: exp(R1)*(2.3695/c)\n",
    "\t          c=[-3.2828 11.8393 17.4884 -15.1295 9.2678 19.6123]\n\n",
    "Therefore it is recommended to use only upper case names for any ",
    "other primitives when using multiple particle types. ",
    "The 2- and 3- body contant vectors have their own mutation operators ",
    "and registers. The operators for 2- and 3- body (respectively):\n\n",
    "\t<GP-MutationEphemeral2COp/>\n",
    "\t<GP-MutationEphemeral3COp>\n\n",
    "and the registers are:\n\n",
    "\t<Entry key=\"gp.mute2c.indpb\">0.05</Entry>\n",
    "\t<Entry key=\"gp.mute2c.primit\">E_p</Entry>\n",
    "\t<Entry key=\"gp.mute3c.indpb\">0.05</Entry>\n",
    "\t<Entry key=\"gp.mute3c.primit\">E_t</Entry>\n\n",
    "If hybrid local search is used during the optimization "
    "and gp.hybopt.mtypes is non-zero (default), "
    "local optimization of contant vectors will automatically be ",
    "performed in addition to the primitive specified by ",
    "the gp.hybopt.primit register. If gp.hybopt.type register is 0 ",
    "all constants in the vectors will be optimized. If it is 1 ",
    "all of the contants in 1 chosen vector might be optimized. ",
    "Optimization of multiple ",
    "particle types is currently limited to vectorized simulations."
    "The register gp.simplify.maxe is ignored when multiple particle ",
    "types are used; in this case, the entire dataset is used to determine ",
    "invariance.\n\n"
  };
  cl.addtoman_chapter("MUTIPLE PARTICLE TYPES",61,mtypes);
  
  const std::string limitations[14]={
    "Fitness metrics in PM-Dreamer are limited to those that generate ",
    "floating points >=0 and <=1 with 1 representing a perfect match ",
    "to machine precision. For certain functions, the input variables ",
    "are only checked during initialization and therefore cannot change ",
    "in the middle of a run. The following epsilon values are currently ",
    "hard coded in PM-Dreamer:\n\n",
    "\\fB1e-8\\fR .TP Epsilon for forward finite difference.\n\n",
    "\\fB1e-8 and 1e16\\fR .TP Are the minimum and maximum ranges for test data ",
    "evaluated using a correlation coefficient or OLS.\n\n",
    "The primitive names E_p and E_t should only be used in optimizations ",
    "involving multiple particle types as described above. ",
    "The register gp.simplify.maxe is ignored when multiple particle ",
    "types are used; in this case, the entire dataset is used to determine ",
    "invariance.\n\n"
  };
  cl.addtoman_chapter("LIMITATIONS",14,limitations);
  
  // Authors
  cl.addtoman_chapter("AUTHORS","W. Michael Brown");
}
